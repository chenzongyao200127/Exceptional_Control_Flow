# Nonlocal Jumps
# 非本地跳转

C 语言提供了一种用户级异常控制流形式，称为非本地跳转（`non local jump`），它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用—返回序列。非本地跳转是通过 `setjmp` 和 `longjmp` 函数来提供的。

非局部跳转（non-local jump）是编程中的一个概念，它指的是控制流程跳出当前执行环境到另一个代码块，而不是通过正常的函数调用/返回机制。在 C 语言中，这通常是通过 `setjmp` 和 `longjmp` 函数实现的。
这些函数提供了一种机制，用于在程序的不同部分之间进行跳转，这种跳转通常用于错误处理和信号处理等场景。

### 如何工作

1. **`setjmp`**:
   - `setjmp` 用于设置跳转点。它通常在 `try` 块的开始处调用，并将当前的环境（包括程序计数器、堆栈指针和寄存器值等）保存在一个 `jmp_buf` 类型的变量中。
   - `setjmp` 在初始调用时返回 `0`。

2. **`longjmp`**:
   - 当需要进行非局部跳转时，调用 `longjmp`。它使用 `setjmp` 提供的 `jmp_buf` 变量来恢复先前保存的环境，并跳转回 `setjmp` 的位置。
   - `longjmp` 导致 `setjmp` 返回一个非零值，这允许程序区分初始调用和跳转回来的情况。

### 用途

- **错误处理**：在深层嵌套的函数调用中，当发生错误时，可以使用非局部跳转直接跳回到主控制流程，而不是逐级返回。
- **信号处理**：在信号处理函数中，可能使用非局部跳转来跳出正常的执行流程，特别是在不可能简单恢复的错误情况下。
- **事件驱动编程**：在某些事件驱动或状态机编程模型中，也可能使用非局部跳转来实现状态的转换。

### 示例

```c
#include <stdio.h>
#include <setjmp.h>

jmp_buf jump_buffer;

void my_function() {
    // 遇到错误情况，跳转
    longjmp(jump_buffer, 1);
}

int main() {
    if (setjmp(jump_buffer) == 0) {
        // 正常执行
        printf("Calling my_function\n");
        my_function();
        printf("my_function returned\n");
    } else {
        // 从 my_function 的 longjmp 跳转回来
        printf("Jumped back from my_function\n");
    }
    return 0;
}
```

### 注意事项

- 非局部跳转跳过了正常的堆栈展开过程，因此可能导致资源泄漏，如未释放的内存或未关闭的文件描述符。
- 应谨慎使用非局部跳转，确保理解它对程序状态的影响，并采取措施避免资源泄漏等问题。
- 在 C++ 程序中，非局部跳转会跳过对象的析构函数调用，因此使用异常处理通常是更好的选择。


~~~c
#include <setjmp.h>
int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);

// 返回：setjmp 返回 0，longjmp 返回非零。
~~~

`setjmp` 函数在 env 缓冲区中保存当前调用环境，以供后面的 `longjmp` 使用，并返回 0
调用环境包括程序计数器、栈指针和通用目的寄存器。岀于某种超出本书描述范围的原因，setjmp 返回的值不能被赋值给变量：

在 C 语言中，`setjmp` 的返回值不应该被直接赋值给一个变量，原因在于 `setjmp`/`longjmp` 机制的工作方式。
`setjmp` 函数在第一次被调用时返回 `0`，而当通过 `longjmp` 跳回到 `setjmp` 的位置时，它返回的是 `longjmp` 提供的非零值。
这种行为使得 `setjmp`/`longjmp` 成为处理错误和异常情况的一种机制。

### 为什么不应直接赋值

1. **编译器优化**：编译器可能会对涉及 `setjmp` 返回值的代码进行优化，这可能导致在 `longjmp` 调用后，返回值不正确地反映在赋值变量上。编译器在优化代码时可能不会考虑到 `setjmp`/`longjmp` 的非局部跳转特性。

2. **不确定的执行流**：由于 `setjmp`/`longjmp` 的执行流是不确定的（特别是在涉及多次 `longjmp` 跳转到同一个 `setjmp` 点时），将 `setjmp` 的返回值赋值给一个变量可能导致程序逻辑混乱，难以追踪和维护。

### 推荐的做法

一种更安全且常见的做法是直接在 `setjmp` 调用的条件表达式中测试返回值：

```c
jmp_buf env;
if (setjmp(env) == 0) {
    // 初始调用，返回值为 0
} else {
    // 从 longjmp 跳回，返回值非 0
}
```

这种做法确保了每次调用 `setjmp` 时都会立即检查其返回值，减少了由于编译器优化或不确定的执行流导致的潜在问题。

总之，由于 `setjmp`/`longjmp` 的特殊性和复杂性，推荐直接在 `if` 语句中使用 `setjmp`，避免将其返回值赋值给变量。
这样做有助于编写更清晰、更可靠的代码。

~~~c
rc = setjmp(env);  /* Wrong! */
~~~
不过它可以安全地用在 switch 或条件语句的测试中【62】。

~~~c
#include <setjmp.h>

void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);

// 从不返回。
~~~

`longjmp` 函数从 `env` 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 `env` 的 `setjmp` 调用的返回。
然后 `setjmp` 返回，并带有非零的返回值 `retval`。

第一眼看过去，`setjmp` 和 `longjmp` 之间的相互关系令人迷惑。`setjmp` 函数只被调用一次，但返回多次：一次是当第一次调用 `setjmp`，而调用环境保存在缓冲区 `env` 中时，一次是为每个相应的 `longjmp` 调用。另一方面，`longjmp` 函数被调用一次，但从不返回。

非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。
如果在一个深层嵌套的函数调用中发现了一个错误情况，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。

====================================================================================================
非本地跳转（如 C 语言中的 `setjmp` 和 `longjmp`）可以理解为一种“紧急撤离”机制。在编程中，这种机制允许你从程序的一个深层次部分“快速撤退”到一个更高层次的点，特别是在遇到错误或异常情况时。

### 通俗比喻

想象一下你在玩一个电子游戏，你的角色深入到了一个复杂的迷宫中。在游戏中，如果你遇到一个危险的情况（比如怪物或陷阱），而你又没有时间或能力一层层回到出口，游戏可能提供了一个“紧急传送”按钮，让你立即返回到安全的地方。

在这个比喻中，深入迷宫的过程就像是程序中的深层嵌套函数调用，而“紧急传送”按钮就像是非本地跳转。
当你在程序的深层逻辑中发现了一个严重错误，而且这个错误意味着你不能继续当前的操作时，你可以使用非本地跳转立即返回到程序中的一个安全点，通常是一个专门用于错误处理的部分。

### 编程中的应用

在实际的编程应用中，如果一个函数在执行过程中遇到了无法处理的错误，通常需要逐层向上返回（即每个函数依次返回到它的调用者），直到某个能够处理这个错误的函数。这个过程可能既复杂又低效，特别是在深层嵌套的函数调用中。

使用非本地跳转，你可以避免这个复杂的逐层返回过程。相反，你可以立即从错误发生的地方跳转到错误处理代码，就像按下了“紧急传送”按钮一样。这样不仅使得代码更简洁，而且在某些情况下也更高效。

### 注意事项

虽然非本地跳转很有用，但也需要谨慎使用。因为它会跳过正常的栈展开过程，可能会导致资源泄露（如未关闭的文件句柄）或其他清理操作未被执行。因此，它主要用于那些异常处理的情况，且应确保在跳转后适当地管理资源和状态。
====================================================================================================

图 8-43 展示了一个示例，说明这可能是如何工作的。
main 函数首先调用 setjmp 以保存当前的调用环境，然后调用函数 foo，foo 依次调用函数 bar。
如果 foo 或者 bar 遇到一个错误，它们立即通过一次 longjmp 调用从 setjmp 返回。
*`setjmp` 的非零返回值指明了错误类型，随后可以被解码，且在代码中的某个位置进行处理。*

~~~c
#include "csapp.h"

jmp_buf buf;

int error1 = 0;
int error2 = 1;

void foo(void), bar(void);

int main()
{
    switch (setjmp(buf)) {
    case 0:
        foo();
        break;
    case 1:
        printf("Detected an error1 condition in foo\n");
        break;
    case 2:
        printf("Detected an error2 condition in foo\n");
        break;
    default:
        printf("Unknown error condition in foo\n");
    }
    exit(0);
}

/* Deeply nested function foo */
void foo(void)
{
    if (error1)
        longjmp(buf, 1);
    bar();
}

void bar(void)
{
    if (error2)
        longjmp(buf, 2);
}
~~~

longjmp 允许它跳过所有中间调用的特性可能产生意外的后果。
例如，如果中间函数调用中分配了某些数据结构，本来预期在函数结尾处释放它们，那么这些释放代码会被跳过，因而会产生内存泄漏。

非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。图 8-44 展示了一个简单的程序，说明了这种基本技术。
当用户在键盘上键入 Ctrl+C 时，这个程序用信号和非本地跳转来实现软重启。`sigsetjmp` 和 `siglongjmp` 函数是 setjmp 和 longjmp 的可以被信号处理程序使用的版本。

~~~c
#include "csapp.h"

sigjmp_buf buf;

void handler(int sig)
{
    siglongjmp(buf, 1);
}

int main()
{
    if (!sigsetjmp(buf, 1)) {
        Signal(SIGINT, handler);
        Sio_puts("starting\n");
    }
    else
        Sio_puts("restarting\n");

    while (1) {
        Sleep(1);
        Sio_puts("processing...\n");
    }
    exit(0); /* Control never reaches here */
}
~~~

在程序第一次启动时，对 `sigsetjmp` 函数的初始调用保存调用环境和信号的上下文（包括待处理的和被阻塞的信号向量）。
随后，主函数进入一个无限处理循环。当用户键入 `Ctrl+C` 时，内核发送一个 SIGINT 信号给这个进程，该进程捕获这个信号。
不是从信号处理程序返回，如果是这样那么信号处理程序会将控制返回给被中断的处理循环，反之，处理程序完成一个非本地跳转，回到 `main` 函数的开始处。当我们在系统上运行这个程序时，得到以下输出：

~~~shell
linux> ./restart
starting
processing...
processing...
Ctrl+C
restarting
processing...
Ctrl+C
restarting
processing...
~~~

关于这个程序有两件很有趣的事情。
- 首先，为了避免竞争，必须在调用了 `sigsetjmp` 之后再设置信号处理程序。否则，就会冒在初始调用 sigsetjmp 为 siglongjmp 设置调用环境之前這行处理程序的风险。
- 其次，你可能已经注意到了，sigsetjmp 和 siglongjmp 函数不在图 8-33 中异步信号安全的函数之列。原因是一般来说 siglongjmp 可以跳到任意代码，所以我们必须小心，只在 siglongjmp 可达的代码中调用安全的函数。
- 在本例中，我们调用安全的 sio_puts 和 sleep 函数。不安全的 exit 函数是不可达的。

您提供的代码是一个使用 `sigsetjmp` 和 `siglongjmp` 函数来处理信号的示例。
这个程序在接收到 `SIGINT` 信号（通常由 `Ctrl+C` 触发）时，通过非本地跳转来改变程序的正常执行流程。下面是代码的分析和解释：

### 代码解释

1. **全局变量**:
   - `sigjmp_buf buf;` 定义了一个全局的跳转缓冲区 `buf`，它被用于存储 `sigsetjmp` 设置的环境。

2. **信号处理函数（handler）**:
   - `handler` 函数是 `SIGINT` 信号的处理函数。当接收到信号时，它调用 `siglongjmp`，使程序跳转回 `sigsetjmp` 的位置。

3. **主函数（main）**:
   - `sigsetjmp(buf, 1)` 设置一个非本地跳转点，并在第一次调用时返回 `0`。参数 `1` 表示在跳转时保存信号屏蔽状态。
   - 如果 `sigsetjmp` 返回 `0`（即程序第一次运行到这点），则设置 `SIGINT` 信号的处理函数为 `handler`，并输出 "starting"。
   - 如果是从 `handler` 函数跳回（`siglongjmp` 被调用），则 `sigsetjmp` 返回非零值，程序输出 "restarting"。
   - 接着程序进入一个无限循环，每隔一秒输出 "processing..."。

4. **退出**:
   - `exit(0);` 这行代码实际上永远不会被执行，因为前面的 `while` 循环是无限的。

### 信号处理的流程

- 当用户在程序运行时按下 `Ctrl+C`，`SIGINT` 信号被发送到程序。
- `handler` 函数捕获这个信号，并通过调用 `siglongjmp` 跳转回 `sigsetjmp` 的位置。
- 这次跳转导致 `sigsetjmp` 返回非零值，因此程序打印 "restarting"，然后继续无限循环。

### 特点和用途

- 这个程序演示了如何使用 `sigsetjmp`/`siglongjmp` 来处理信号，并在信号到来时改变程序的执行流程。
- 这种机制在需要快速响应信号并从深层嵌套的函数调用中恢复时非常有用。

### 注意事项

- 使用 `sigsetjmp` 和 `siglongjmp` 时需要特别注意，因为它们会跳过正常的栈展开和局部变量的清理。这可能导致资源泄露或其他状态一致性问题。
- 在实际应用中，这种技术应谨慎使用，并且通常仅限于特定的异常处理场景。



### 1. 避免竞争：设置信号处理程序的时机

- 当使用 `sigsetjmp` 和 `siglongjmp` 进行信号处理时，确保在调用 `sigsetjmp` 之后设置信号处理程序是关键的。
如果在 `sigsetjmp` 调用之前设置信号处理程序，存在一个竞争条件的风险。
这种情况下，如果信号在 `sigsetjmp` 设置跳转环境之前到达，`siglongjmp` 可能会跳转到一个未正确初始化的环境。
- 确保先调用 `sigsetjmp` 可以确保即使信号处理程序被触发，`siglongjmp` 也会跳转到一个已经设置好的环境。

### 2. 使用 sigsetjmp 和 siglongjmp 的限制

- `sigsetjmp` 和 `siglongjmp` 不在异步信号安全的函数列表中。
这意味着它们在信号处理程序中的使用需要特别小心，因为它们可能会与正常的程序执行流程发生冲突。
- 使用 `siglongjmp` 进行跳转时，必须确保跳转的目标是安全的，也就是说，跳转的目标代码必须只包含异步信号安全的函数。
这是因为 `siglongjmp` 可以跳到任意代码，如果跳转到包含不安全函数的代码，可能会导致未定义的行为或程序崩溃。

### 3. 示例中的函数选择

- 在您提到的示例中，使用了 `sio_puts` 和 `sleep` 函数，这些都是异步信号安全的。这意味着它们在信号处理程序中使用时不会导致问题。
- 另一方面，`exit` 函数不是异步信号安全的，但在示例中它是不可达的，因此不会被执行。这避免了潜在的安全问题。

### 总结

在处理信号和使用 `sigsetjmp`/`siglongjmp` 时，必须谨慎考虑程序的控制流和函数的选择，以避免竞争条件和不稳定的行为。正确的做法是在 `sigsetjmp` 后设置信号处理程序，并确保 `siglongjmp` 跳转到的代码只包含异步信号安全的函数。这样可以确保程序在面对信号时的行为既稳定又可预测。


> 旁注 - C++ 和 Java 中的软件异常
> C++ 和 Java 提供的异常机制是较高层次的，是 C 语言的 setjmp 和 longjmp 函数的更加结构化的版本。你可以把 try 语句中的 catch 子句看做类似于 setjmp 函数。相似地，throw 语句就类似于 longjmp 函数。

您提到的是 C++ 和 Java 中的异常处理机制与 C 语言中的 `setjmp`/`longjmp` 函数之间的类比。
这个类比有助于理解高级语言中的异常处理机制如何提供了类似于 `setjmp`/`longjmp` 的功能，但以更加结构化和安全的方式实现。

### C 语言的 `setjmp` 和 `longjmp`

- **`setjmp`/`longjmp`** 是 C 语言提供的一种用于处理错误和异常情况的机制。`setjmp` 用于标记程序中的一个点，`longjmp` 用于无条件跳转回那个点，通常用于错误处理。
- **使用方法**：
  - `setjmp` 通常在某个函数的开始处调用，以设置一个“回跳点”。
  - 当发生错误时，使用 `longjmp` 跳回之前通过 `setjmp` 设置的点。

### C++ 和 Java 中的异常处理

- **`try` 和 `catch`**：
  - `try` 块用于包围可能产生异常的代码。
  - `catch` 子句用于捕获和处理特定类型的异常。
- **`throw`**：
  - 用于抛出一个异常，这相当于告诉程序出现了某种错误或异常情况。

### 类比

- **`setjmp` 类似于 `try`**：在 `setjmp`/`longjmp` 中，`setjmp` 调用定义了一个跳转点，类似于在 C++/Java 中 `try` 块定义了一个异常可能发生的区域。
- **`longjmp` 类似于 `throw`**：`longjmp` 提供了一种机制来跳转回 `setjmp` 的位置，类似于在 C++/Java 中 `throw` 用于触发一个异常，将控制权转移到相应的 `catch` 块。

### 示例

#### C 语言示例

```c
#include <setjmp.h>
#include <stdio.h>

jmp_buf jump_buffer;

void someFunction() {
    // 发生错误
    longjmp(jump_buffer, 1);
}

int main() {
    if (setjmp(jump_buffer) == 0) {
        // 正常执行
        someFunction();
    } else {
        // 错误处理
        printf("Error occurred\n");
    }
    return 0;
}
```

#### C++ 语言示例

```cpp
#include <iostream>
using namespace std;

void someFunction() {
    // 发生错误
    throw "Error occurred";
}

int main() {
    try {
        // 尝试执行
        someFunction();
    } catch (const char* msg) {
        // 捕获并处理异常
        cout << msg << endl;
    }
    return 0;
}
```

### 总结

在 C++ 和 Java 中，异常处理机制提供了一种更加结构化、易于理解和安全的方式来处理错误和异常情况，与 C 语言中 `setjmp`/`longjmp` 的基本理念相似，但在使用上更加直观和强大。通过使用 `try`/`catch` 和 `throw`，开发者可以以更优雅的方式编写健壮且易于维护的错误处理代码。





# 什么是异步信号安全

异步信号安全（Asynchronous Signal Safety）指的是在处理信号时，能够安全调用的函数。
当程序接收到信号并执行信号处理函数时，可能会中断程序的正常执行流程。
如果此时信号处理函数调用了某些不安全的函数，则可能导致程序行为不可预测，甚至出现严重的错误，如数据损坏或程序崩溃。

异步信号安全的函数是那些在信号处理函数中调用时不会导致问题的函数。这些函数保证在信号处理期间不会和其他正常执行的代码发生冲突，比如不会操作全局状态、不会分配或释放内存等。

### 不安全的例子

一个典型的不安全的例子是在信号处理函数中使用标准 I/O 函数，如 `printf`。

```c
#include <stdio.h>
#include <signal.h>

void signal_handler(int sig) {
    printf("Received signal %d\n", sig); // 不安全
}

int main() {
    signal(SIGINT, signal_handler);
    // ... 其他代码 ...
}
```

**为什么不安全**:
- 当 `printf` 被信号处理函数调用时，如果主程序也在使用 `printf` 或其他标准 I/O 函数，那么信号处理可能会在这些函数的中间执行，打乱它们的内部状态。
- 标准 I/O 函数如 `printf` 经常操作内部的缓冲区和数据结构。如果信号处理函数中断了这些操作，可能会导致数据结构处于不一致的状态，进而导致未定义的行为，比如输出乱码、程序崩溃等。

### 通俗解释

可以把异步信号安全想象成是在烹饪时安全使用厨房设备的规则。假设你在做饭，突然铃声响了（类似于程序收到信号）。
如果你立刻去应门，而忘记关掉正在使用的炉子或烤箱，这可能会导致食物烧焦或更糟糕的事情发生。
同样，在程序的信号处理函数中使用某些函数，就像是在应门时忘了关炉子一样，可能会导致程序的“厨房”发生混乱。

总之，异步信号安全是确保信号处理函数中不会因为调用某些可能干扰程序正常运行的函数而引发问题的一种保障机制。
正确地处理信号是编写稳定和可靠程序的重要部分。



# 为什么 `write()`是信号安全的？
`write` 函数被认为是异步信号安全的，原因在于它的实现方式和它在操作系统级别上的行为。在 Unix 和类 Unix 系统中，`write` 是一个系统调用，它直接与内核交互来执行 I/O 操作。以下是使 `write` 成为异步信号安全函数的一些关键因素：

### 原子操作

- **系统级原子性**：`write` 对于某些特定的文件类型（如管道、FIFO、套接字等）执行原子操作。这意味着一旦一个 `write` 操作开始，它会作为一个整体完成，不会被其他的 `write` 调用或信号处理中断。
- **无内部缓冲**：不同于标准 I/O 函数（如 `printf`），`write` 不使用用户空间的缓冲区。它直接向文件描述符写入数据，避免了缓冲区相关的状态不一致问题。

### 简单性和可预测性

- **直接与内核交互**：`write` 作为系统调用，直接与操作系统内核交互，减少了因用户空间复杂逻辑而导致的不可预测性。
- **简单的行为**：`write` 执行单一的操作（写数据），不涉及复杂的逻辑或状态修改，这使得它在信号处理程序中使用时行为可预测。

### 异常处理

- **错误码返回**：如果 `write` 在执行中遇到错误（例如由于信号中断），它会返回一个错误码（如 `EINTR`），并不会破坏程序的其他部分。这使得程序可以根据需要安全地处理这些错误。

### 通俗解释

可以将 `write` 比作在紧急情况下快速记录一条信息，比如在地震中抓起笔迅速在纸上写下“我在这里”。这个动作简单、直接，不涉及打开新的笔记本或查找特定的纸张。同样地，`write` 在处理信号时简单、直接，不依赖复杂的内部状态或缓冲区。

### 结论

由于这些特性，`write` 被视为在信号处理程序中安全使用的函数之一。然而，即使 `write` 是异步信号安全的，开发者仍需谨慎使用，特别是在考虑多线程环境和程序的整体结构时。s