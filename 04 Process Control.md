# Process Control
# 进程控制

Unix 提供了大量从 C 程序中操作进程的系统调用。这一节将描述这些重要的函数，并举例说明如何使用它们。

Unix提供了一系列强大的系统调用，允许C程序创建和管理进程。这些系统调用是Unix风格操作系统进程管理的基础。以下是一些重要的进程操作系统调用及其用法示例：

### 1. fork()

- **用途**：创建一个新的子进程，它是当前进程的副本。
- **行为**：`fork()`调用一次，返回两次。在父进程中返回子进程的PID，在子进程中返回0。
- **示例**：
  ```c
  pid_t pid = fork();
  if (pid == -1) {
      // 错误处理
  } else if (pid == 0) {
      // 子进程代码
  } else {
      // 父进程代码
  }
  ```

### 2. exec()

- **用途**：在当前进程中加载和运行一个新程序。`exec()`系列函数有多种（如`execl()`, `execp()`, `execv()`等），区别在于如何指定程序和参数。
- **行为**：替换当前进程的映像，包括代码和数据。成功调用后不返回。
- **示例**：
  ```c
  if (fork() == 0) {
      execl("/bin/ls", "ls", "-l", (char *)NULL);
      // 如果exec()失败
      perror("exec failed");
      exit(EXIT_FAILURE);
  }
  ```

### 3. wait() / waitpid()

- **用途**：等待子进程结束。
- **行为**：`wait()`挂起当前进程，直到一个子进程结束。`waitpid()`可以等待特定的子进程，并提供更多的控制。
- **示例**：
  ```c
  pid_t pid = fork();
  if (pid == -1) {
      // 错误处理
  } else if (pid == 0) {
      // 子进程代码
  } else {
      int status;
      waitpid(pid, &status, 0); // 等待特定的子进程
      // 检查子进程的退出状态
  }
  ```

### 4. exit()

- **用途**：结束进程执行。
- **行为**：终止当前进程，返回一个状态码给父进程。
- **示例**：
  ```c
  if (fork() == 0) {
      // 子进程代码
      exit(0); // 成功退出
  }
  ```

### 5. getpid() / getppid()

- **用途**：`getpid()`用于获取当前进程的PID，`getppid()`用于获取父进程的PID。
- **示例**：
  ```c
  pid_t my_pid = getpid();
  pid_t parent_pid = getppid();
  ```

这些系统调用是Unix/Linux进程管理的基石，它们为操作系统提供了丰富的进程控制功能，从而使得Unix/Linux成为强大的多任务操作系统。
在使用这些调用时，理解它们的行为和可能的陷阱（比如正确处理`fork()`的返回值，以及`exec()`成功时不返回）是非常重要的。


====================================================================================================