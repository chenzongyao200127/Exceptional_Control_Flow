# System Call Error Handling
# 系统调用错误处理

当 Unix 系统级函数遇到错误时，它们通常会返回 `—1`，并设置全局整数变量 `errno` 来表示什么出错了。
程序员应该总是检査错误，但是不幸的是，许多人都忽略了错误检查，因为它使代码变得臃肿，而且难以读懂。
比如，下面是我们调用 Unix fork 函数时会如何检査错误：

~~~c
if ((pid = fork()) < 0) {
    fprintf(stderr, "fork error: %s\n", strerror(errno));
    exit(0);
}
~~~

`strerror` 函数返回一个文本串，描述了和某个 errno 值相关联的错误。
通过定义下面的错误报告函数，我们能够在某种程度上简化这个代码：

~~~c
void unix_error(char *msg) /* Unix-style error */
{
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(0);
}
~~~

给定这个函数，我们对 fork 的调用从 4 行缩减到 2 行：
~~~c
if ((pid = fork()) < 0)
    unix_error("fork error");
~~~

通过使用错误处理包装函数，我们可以更进一步地简化代码，Stevens 在【110】中首先提出了这种方法。
对于一个给定的基本函数 `foo`，我们定义一个具有相同参数的包装函数 `Foo`，但是第一个字母大写了。
包装函数调用基本函数，检査错误，如果有任何问题就终止。比如，下面是 fork 函数的错误处理包装函数

~~~c
pid_t Fork(void)
{
    pid_t pid;
  
    if ((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}
~~~

给定这个包装函数，我们对 fork 的调用就缩减为 1 行：
~~~c
pid = Fork();
~~~

我们将在本书剩余的部分中都使用*错误处理包装函数*。
它们能够保持代码示例简洁，而又不会给你错误的假象，认为允许忽略错误检査。
注意，当在本书中谈到系统级函数时，我们总是用它们的小写字母的基本名字来引用它们，而不是用它们大写的包装函数名来引用。

关于 Unix 错误处理以及本书中使用的错误处理包装函数的讨论，请参见附录 A。
包装函数定义在一个叫做 `csapp.c` 的文件中，它们的原型定义在一个叫做 `csapp.h` 的头文件中；可以从 CS：APP 网站上在线地得到这些代码。


====================================================================================================
在编程中，错误处理包装函数（`Error Handling Wrapper Functions`）是一种设计模式，用于简化对可能出错的函数调用的处理。
这些包装函数会在调用某个可能失败的原始函数（如系统调用或库函数）后检查错误，并采取适当的措施，如记录错误、重试或退出程序。
这种方法有助于提高代码的可读性和可维护性，同时确保错误被一致和系统地处理。

### 错误处理包装函数的特点

1. **自动化错误检查**：包装函数自动检查被封装函数的返回值或设置的错误码，判断操作是否成功。

2. **统一的错误处理**：在包装函数中统一处理错误，如打印错误信息、清理资源或抛出异常，
                     从而避免在代码的多个地方重复相同的错误处理逻辑。

3. **提高代码清晰度**：使主逻辑代码更加清晰，因为错误处理代码被移到了单独的函数中。

### 示例

以C语言为例，如果有一个系统调用`read`，它在读取文件失败时返回-1。不使用错误处理包装函数的代码可能看起来像这样：

```c
ssize_t bytes_read;
bytes_read = read(fd, buffer, size);
if (bytes_read == -1) {
    // 错误处理
    perror("read failed");
    exit(EXIT_FAILURE);
}
```

使用错误处理包装函数后，代码可以简化为：

```c
ssize_t bytes_read;
bytes_read = Read(fd, buffer, size); // Read 是封装了错误处理的包装函数
```

其中`Read`是一个包装函数，内部实现可能如下：

```c
ssize_t Read(int fd, void *buffer, size_t size) {
    ssize_t result = read(fd, buffer, size);
    if (result == -1) {
        perror("read failed");
        exit(EXIT_FAILURE);
    }
    return result;
}
```

### 应用

错误处理包装函数在系统编程、网络编程等需要频繁进行错误检查的场景中特别有用。
这些领域的函数调用往往伴随着许多潜在的错误情况，例如文件操作失败、
网络连接中断等，使用错误处理包装函数可以大幅简化代码的复杂性。