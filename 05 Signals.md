# Signals
# 信号

[toc]
1. 信号术语
2. 发生信号
    1. 进程组
    2. `/bin/kill`
    3. 作业
    4. `kill()`
    5. `alarm`
3. 接受信号
4. 阻塞和接触阻塞信号
5. 编写信号处理程序
6. 同步流以避免讨厌的并发错误
7. 显式地等待信号




到目前为止对异常控制流的学习中，我们已经看到了硬件和软件是如何合作以提供基本的低层异常机制的。
我们也看到了操作系统如何利用异常来支持进程上下文切换的异常控制流形式。
在本节中，我们将研究一种更高层的软件形式的异常，称为 Linux 信号，它允许进程和内核中断其他进程。

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。比如，图 8-26 展示了 Linux 系统上支持的 30 种不同类型的信号。

每种信号类型都对应于某种系统事件。

低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。
信号提供了一种机制，通知用户进程发生了这些异常。
比如，如果一个进程试图除以 0，那么内核就发送给它一个 SIGFPE 信号（号码 8）。
如果一个进程执行一条非法指令，那么内核就发送给它一个 SIGILL 信号（号码 4）。
如果进程进行非法内存引用，内核就发送给它一个 SIGSEGV 信号（号码 11）。

其他信号对应于内核或者其他用户进程中较高层的软件事件。
比如，如果当进程在前台运行时，你键入 Ctrl+C（也就是同时按下 Ctrl 键和 C 键），那么内核就会发送一个 SIGINT 信号（号码 2）给这个前台进程组中的每个进程。
一个进程可以通过向另一个进程发送一个 SIGKILL 信号（号码 9）强制终止它。
当一个子进程终止或者停止时，内核会发送一个 SIGCHLD 信号（号码 17）给父进程。

在 Linux 系统中，存在多种信号（Signals），每种信号都对应一个特定的事件，且具有默认的处理行为。以下是 Linux 支持的一些常见信号的列表，包括信号的编号（Number）、名称（Name）、默认行为（Default Action），以及对应事件（Corresponding Event）：
~~~shell
| Number | Name      | Default Action | Corresponding Event                      |
| ------ | --------- | -------------- | ---------------------------------------- |
| 1      | SIGHUP    | Terminate      | 终端控制进程结束或控制终端关闭           |
| 2      | SIGINT    | Terminate      | 键盘中断（如 ctrl + c）                  |
| 3      | SIGQUIT   | Core           | 键盘退出信号                             |
| 4      | SIGILL    | Core           | 非法指令                                 |
| 5      | SIGTRAP   | Core           | 跟踪/断点捕获                            |
| 6      | SIGABRT   | Core           | Abort 信号由 abort(3) 发起               |
| 7      | SIGBUS    | Core           | 总线错误（错误的内存访问）               |
| 8      | SIGFPE    | Core           | 浮点异常                                 |
| 9      | SIGKILL   | Terminate      | 强制终止                                 |
| 10     | SIGUSR1   | Terminate      | 用户自定义信号1                          |
| 11     | SIGSEGV   | Core           | 无效的内存引用                           |
| 12     | SIGUSR2   | Terminate      | 用户自定义信号2                          |
| 13     | SIGPIPE   | Terminate      | 管道破裂: 写入无进程读取的管道           |
| 14     | SIGALRM   | Terminate      | 计时器信号（由 alarm(2) 发起）           |
| 15     | SIGTERM   | Terminate      | 终止信号                                 |
| 16     | SIGSTKFLT | Terminate      | 栈故障（不常用）                         |
| 17     | SIGCHLD   | Ignore         | 子进程结束信号                           |
| 18     | SIGCONT   | Continue       | 继续执行暂停的进程                       |
| 19     | SIGSTOP   | Stop           | 停止进程的执行                           |
| 20     | SIGTSTP   | Stop           | 终端停止信号                             |
| 21     | SIGTTIN   | Stop           | 后台进程从终端读取数据时                 |
| 22     | SIGTTOU   | Stop           | 后台进程向终端写数据时                   |
| 23     | SIGURG    | Ignore         | I/O紧急信号                              |
| 24     | SIGXCPU   | Core           | 超出CPU时间限制（由 setrlimit(2) 设置）  |
| 25     | SIGXFSZ   | Core           | 超出文件大小限制（由 setrlimit(2) 设置） |
| 26     | SIGVTALRM | Terminate      | 虚拟计时器到期（由 setitimer(2) 设置）   |
| 27     | SIGPROF   | Terminate      | 性能分析计时器到期                       |
| 28     | SIGWINCH  | Ignore         | 窗口大小变化                             |
| 29     | SIGIO     | Terminate      | I/O相关的可用或紧急信号                  |
| 30     | SIGPWR    | Terminate      | 电源故障（不常用）                       |
| 31     | SIGSYS    | Core           | 无效的系统调用                           |
~~~

这张表列出了 Linux 支持的一些常见信号及其属性。值得注意的是，不同的 Unix-like 系统可能在信号的具体实现上有所差异。
此外，程序可以自定义对大多数信号的响应，但有两个信号 `SIGKILL` 和 `SIGSTOP` 不能被捕获、阻塞或忽略。

> ① 多年前，主存是用一种称为磁芯存储器（core memory）的技术来实现的。“转储内存”（dumping core）是一个历史术语，意思是把代码和数据内存段的映像写到磁盘上。
> ② 这个信号既不能被捕获，也不能被忽略。
> （来源：man 7 signal。数据来自 Linux Foundation。）

信号系统是操作系统中用于进程间通信的一种机制，它主要用于通知进程发生了某种类型的事件。
这个机制相当于是一个异步的通知服务，它允许操作系统或其他进程向一个进程发送消息，告诉它发生了某个事件（如错误、外部中断等）。
信号系统的存在有几个重要的用途和优点：

### 通知和处理异常事件

- **异常处理：** 当程序出现异常情况（如非法访问内存、除零错误等）时，操作系统可以向该程序发送信号，从而通知程序出现了异常。这允许程序执行相应的异常处理代码，或者干脆终止运行以避免更大的问题。
  
### 控制进程

- **进程控制：** 信号可以用来控制程序的执行。例如，当你在终端中按下 `Ctrl+C` 时，会向正在运行的程序发送 `SIGINT` 信号，这通常会终止该程序。
  
### 实现进程间通信

- **进程间通信（IPC）：** 信号也可以用作进程间通信的一种方式。一个进程可以向另一个进程发送信号，作为通信的一种手段。例如，一些守护进程（后台服务）可能会通过接收特定信号来清除缓存或重新加载配置。

### 异步事件处理

- **异步通知：** 信号是一种异步机制，意味着接收信号的进程不需要在特定的时间点等待信号的到来，而是在信号到来时操作系统会暂停进程当前的操作，处理信号。

### 协调和管理系统资源

- **资源管理：** 操作系统可以使用信号来管理系统资源。例如，当一个进程运行时间过长，超出了预定的限制时，可以向它发送 `SIGXCPU` 信号，提示或强制该进程终止。

### 总结

信号提供了一种有效的机制来处理各种系统级事件，无论是异常、用户交互还是进程间通信。
由于信号是由操作系统内核管理的，因此它们可以在任何时候发送到任何进程，使得进程能够及时响应外部事件。
信号机制是操作系统功能和灵活性的一个重要组成部分，尤其是在多任务和并发环境中。


## 2. 信号术语
传送一个信号到目的进程是由两个不同步骤组成的：

 - **发送信号** 内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：
    1）内核检测到一个系统事件，比如除零错误或者子进程终止。
    2）一个进程调用了 kill 函数（在下一节中讨论），显式地要求内核发送一个信号给目的进程。
一个进程可以发送信号给它自己。

当操作系统的内核发送（递送）一个信号给目的进程时，其实现机制涉及对目标进程的上下文（context）进行修改。
这个过程大致可以分为以下几个步骤：

### 1. 确定目标进程
- 内核首先需要确定信号的接收者，即目标进程。这通常是由发送信号的进程或内核自身（如在异常发生时）指定的。

### 2. 检查信号投递条件
- 内核检查目标进程是否已经设置了对该信号的特定处理方式，比如忽略信号、捕获信号并执行特定的处理函数，或采取默认行为（如终止进程）。
- 还需要检查目标进程是否有权限接收该信号，特别是当信号是由其他进程发送的时候。

### 3. 更新进程上下文
- 如果信号被接受，内核会更新目标进程的上下文，这包括修改与信号相关的数据结构。
  每个进程都有一个信号表，内核会在这个表中记录哪些信号待处理。
- 对于那些设置了特定处理函数（信号处理器）的信号，内核还会设置必要的信息，以便在进程的执行流恢复时能够调用该处理函数。

### 4. 进程状态变更
- 如果目标进程当前正在运行，内核可能会立即中断其执行，转而处理信号。
- 如果目标进程处于阻塞或等待状态（如等待 I/O 完成），内核可能会更改其状态，使其重新调度执行，以便处理信号。

### 5. 信号处理
- 当目标进程下次被调度运行时，它会首先检查待处理的信号，并执行相应的操作，这可能是执行一个信号处理函数，或者进行如终止或暂停等默认操作。

### 6. 返回正常执行
- 一旦信号处理完成（如果有特定的处理函数，则执行完这个函数），进程会返回到原先中断的地方继续执行，或者根据信号处理的结果采取其他行动。

整个过程是操作系统内核对进程上下文的直接干预，确保了信号机制可以作为有效的进程间通信手段和进程控制机制。
这种机制允许操作系统以及进程本身能够及时响应外部事件，是现代操作系统中不可或缺的一部分。

 - **接收信号**。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。
 进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序（`signal handler`）的用户层函数捕获这个信号。

 接收到信号会触发控制转移到`信号处理程序`。在信号处理程序完成处理之后，它将控制返回给被中断的程序

一个发出而没有被接收的信号叫做待处理信号（*pending signal*）。

### 待处理信号（Pending Signals）

- **定义**：待处理信号是指已被发送到进程但还未被进程接收或处理的信号。

- **唯一性**：在任何时刻，对于同一种类型的信号，一个进程最多只能有一个待处理的实例。
如果一个进程已经有一个特定类型的待处理信号，那么后续发送给该进程的同类型信号将不会排队等待，而是被丢弃。

### 信号的阻塞

- **阻塞信号**：进程可以决定阻塞（忽略）某些类型的信号。当一个信号被阻塞时，即使它被发送到进程，也不会立即处理。

- **处理延迟**：阻塞的信号可能成为待处理信号，但只有在进程解除对这种信号的阻塞后，这些待处理信号才可能被处理。

### 内核中的位向量

- **Pending 位向量**：内核为每个进程维护一个待处理信号的集合，通常使用位向量（一组位）来表示。
每个位对应一种信号类型，如果某一位被设置，表示相应类型的信号是待处理状态。

- **Blocked 位向量**：同样，内核也为每个进程维护一个被阻塞的信号集合。
在这个位向量中，每个位代表一种信号类型，被设置的位表示相应的信号类型当前被进程阻塞。

### 信号的接收和清除
- **接收信号**：当一个进程准备好接收某一类型的信号时（例如，解除了该信号的阻塞或者信号未被阻塞），内核会检查对应的待处理信号位向量。
如果找到待处理的信号，内核会安排信号的处理。
- **清除待处理状态**：一旦信号被接收并处理，内核清除该信号类型在待处理位向量中的对应位。

这种机制允许操作系统有效地管理信号，确保进程能够根据自己的状态和需求处理信号，同时避免了信号的过度积累和资源浪费。
通过这种方式，进程可以精确控制哪些信号应该立即处理，哪些可以延迟处理，以及哪些应该被忽略。

✦ `blocked` 位向量✦：也称为信号掩码（`signal mask`）。

让我们通过一个具体的例子来说明待处理信号（pending signals）和阻塞信号（blocked signals）的概念，以及它们如何在实际程序中被使用和处理。

### 场景描述

假设我们有一个程序，它在执行某个关键操作时需要阻塞 `SIGINT`（中断信号，通常由 `Ctrl+C` 触发）以避免操作被中断。
当关键操作完成后，程序将检查是否有任何 `SIGINT` 信号到达并处理它们。

### 代码示例（C 语言）

以下是 C 语言中的一个简单示例：

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void sigint_handler(int sig) {
    write(1, "Caught SIGINT\n", 14);
}

int main() {
    // 设置 SIGINT 的处理函数
    signal(SIGINT, sigint_handler);

    // 阻塞 SIGINT 信号
    sigset_t sigset, oldset;
    sigemptyset(&sigset);
    sigaddset(&sigset, SIGINT);
    sigprocmask(SIG_BLOCK, &sigset, &oldset);

    // 执行关键操作
    printf("Critical operation started\n");
    sleep(5);  // 模拟长时间运行的操作
    printf("Critical operation finished\n");

    // 检查待处理的 SIGINT 信号并解除阻塞
    sigset_t pending;
    sigpending(&pending);
    if (sigismember(&pending, SIGINT)) {
        printf("SIGINT was pending\n");
    }
    sigprocmask(SIG_SETMASK, &oldset, NULL);

    return 0;
}
```

### 解释

- **信号处理**：程序首先定义了 `SIGINT` 信号的处理函数 `sigint_handler`。

- **阻塞信号**：在执行关键操作之前，程序使用 `sigprocmask` 函数阻塞 `SIGINT` 信号。
这意味着即使用户在关键操作期间按下 `Ctrl+C`，`SIGINT` 信号也不会立即被处理。

- **执行关键操作**：程序执行一个模拟的关键操作，这里使用 `sleep` 来模拟。

- **检查待处理信号**：关键操作完成后，程序检查 `SIGINT` 信号是否在待处理信号集中（即是否有 `SIGINT` 信号发送到进程但未被处理）。

- **解除阻塞**：最后，程序解除对 `SIGINT` 信号的阻塞。如果在关键操作期间 `SIGINT` 信号被发送到了进程，那么在解除阻塞后，这个信号会被立即处理。

### 注意

- 这个示例仅用于演示如何使用信号阻塞和检查待处理信号，它并不涵盖所有的最佳实践，如信号处理中的原子操作等。
- 在实际应用中，对信号的处理通常比这个例子更复杂，可能需要更细致的控制和错误处理。


## 发送信号

Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组（process group）这个概念的。

### 1. 进程组

每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。`getpgrp` 函数返回当前进程的进程组 ID：
~~~c
#include <unistd.h>
pid_t getpgrp(void);

// 返回：调用进程的进程组 ID。
~~~

默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用 setpgid 函数来改变自己或者其他进程的进程组：
~~~c
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);

// 返回：若成功则为o，若错误则为 -1。
~~~
setpgid 函数将进程 `pid` 的进程组改为 `pgid`。如果 pid 是 0，那么就使用当前进程的 PID。如果 pgid 是 0，那么就用 pid 指定的进程的 PID 作为进程组 ID。例如，如果进程 15213 是调用进程，那么
~~~c
setpgid(0, 0);
~~~
会创建一个新的进程组，其进程组 ID 是 15213，并且把进程 15213 加入到这个新的进程组中。

====================================================================================================
进程组是 Unix 和类 Unix 系统中用于组织和管理进程的一种机制。在这些系统中，每个进程除了有一个唯一的进程标识符（PID）外，
还属于一个进程组。进程组是对进程进行逻辑分组的一种方式，它允许系统以组为单位管理和控制一组相关进程。
以下是进程组的关键概念和设计目的：

### 进程组的关键概念

1. **进程组标识符（PGID）**：每个进程组都有一个唯一的进程组标识符（PGID），这个标识符通常是该组中第一个进程的 PID。

2. **组成员**：进程组由一个或多个进程组成。这些进程通常是由相同的任务或作业发起的，如一个 shell 命令和它所启动的管道中的所有进程。

3. **生命周期**：进程组的生命周期不依赖于任何单个成员进程的生命周期。当组中最后一个进程终止或离开组时，进程组才会消失。

4. **信号控制**：信号可以被发送到整个进程组，这对于同时控制组内的所有进程非常有用。
例如，当在终端中按下 `Ctrl+C` 时，中断信号 (`SIGINT`) 被发送到前台进程组的所有成员。

### 设计目的

1. **统一管理**：通过将相关进程组织在同一个组内，操作系统可以更方便地对它们进行集中管理。例如，可以一次性地向整个进程组发送信号。

2. **前台和后台作业控制**：在交互式 shell 中，进程组的概念用于区分前台作业和后台作业。前台进程组可以接收来自终端的输入，而后台进程组则不行。

3. **作业控制**：进程组是实现作业控制（job control）的基础。作业控制允许用户在多个程序或命令之间切换，暂停或恢复它们的执行等。

4. **信号处理和会话管理**：进程组简化了信号的处理，使得可以方便地将信号发送给特定组的所有进程。
同时，它也与会话（session）的概念紧密相关，用于管理控制终端和终端登录。

总的来说，进程组是一种强大的机制，它使得 Unix-like 系统能够高效和灵活地管理进程，尤其是在交互式和多任务环境中。
通过进程组，系统能够实现对一组相关进程的集中控制和管理，从而提高了操作系统的使用效率和用户的操作便利性。
====================================================================================================

### 用`/bin/kill`程序发送信号

/bin/kill 程序可以向另外的进程发送任意的信号。比如，命令

~~~shell
linux> /bin/kill -9 15213
~~~
发送信号 9（SIGKILL）给进程 15213。*一个为负的 PID 会导致信号被发送到进程组 PID 中的每个进程*。比如，命令

~~~shell
linux> /bin/kill -9 -15213
~~~

发送一个 `SIGKILL` 信号给进程组 `15213` 中的每个进程。
注意，在此我们使用完整路径 /bin/kill，因为有些 Unix shell 有自己内置的 kill 命令。


### 3. 从键盘发送信号

Unix shell 使用作业（job）这个抽象概念来表示为对一条命令行求值而创建的进程。
在任何时刻，至多只有一个前台作业和 0 个或多个后台作业。比如，键入

~~~shell
linux> ls | sort
~~~

会创建一个由两个进程组成的前台作业，这两个进程是通过 Unix 管道连接起来的：
 - 一个进程运行 ls 程序，另一个运行 sort 程序。
 shell 为每个作业创建一个独立的进程组。进程组 ID 通常取自作业中父进程中的一个。
 
 比如，图 8-28 展示了有一个前台作业和两个后台作业的 shell。前台作业中的父进程 PID 为 20，进程组 ID 也为 20。父进程创建两个子进程，每个也都是进程组 20 的成员。

 在键盘上输入 `Ctrl+C` 会导致内核发送一个 `SIGINT` 信号到*前台进程组*中的每个进程。
 默认情况下，结果是终止前台作业。
 类似地，输入 `Ctrl+Z` 会发送一个 `SIGTSTP` 信号到前台进程组中的每个进程。
 默认情况下，结果是停止（挂起）前台作业。

这种设计允许用户通过键盘输入快捷命令来直接与前台进程组交互，提供了一种简便的方式来控制正在执行的作业。
下面详细解释为什么这样设计以及后台进程是如何被处理的：

====================================================================================================

### 前台进程组的信号处理

1. **直接交互**：前台进程组是用户当前直接与之交互的进程。
因此，将 `Ctrl+C`（SIGINT）和 `Ctrl+Z`（SIGTSTP）信号设计为影响前台进程组，允许用户快速控制当前正在交互的作业。

2. **立即反应**：在用户执行命令或脚本时，可能需要立即停止或中断这些操作。
`Ctrl+C` 提供了一种机制来立即中断正在运行的前台进程，而 `Ctrl+Z` 允许用户挂起进程，稍后再决定是否继续执行。

3. **作业控制**：这种设计是 Unix 作业控制概念的一部分。作业控制允许用户管理多个进程，特别是在使用交互式 shell 环境时。用户可以启动、停止、终止或调整进程的优先级。

### 后台进程组的处理

- **不受键盘信号影响**：后台进程组不会收到来自键盘的 `Ctrl+C` 和 `Ctrl+Z` 信号。这是因为后台作业不应被直接的键盘输入所中断或停止，它们通常是不需要直接用户交互的长时间运行的进程或批处理作业。

- **独立操作**：后台进程可以在用户继续与 shell 交互的同时独立运行。用户可以将一些长时间运行的任务放在后台执行，同时执行其他命令。

- **信号发送**：如果需要，用户可以通过特定的命令（如 `kill`）显式地向后台进程发送信号。例如，如果用户想要停止或终止后台进程，可以使用进程的 PID 或作业控制号来发送相应的信号。

### 总结

这种设计允许 Unix 和类 Unix 系统提供强大的前台和后台作业控制机制。通过使前台进程组对键盘信号敏感，系统为用户提供了一种直观、快速的方式来控制当前活动的进程。同时，后台进程的独立运行能力允许系统更有效地进行多任务处理，提高了系统的灵活性和用户的生产效率。

====================================================================================================

### 4. 用 kill 函数发送信号
进程通过调用 kill 函数发送信号给其他进程（包括它们自己）。

~~~c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);

// 返回：若成功则为 0，若错误则为 -1。
~~~
 - 如果 pid 大于零，那么 kill 函数发送信号号码 sig 给进程 `pid`。
 - 如果 pid 等于零，那么 kill 发送信号 sig 给`调用进程`所在进程组中的每个进程，包括调用进程自己。
 - 如果 pid 小于零，kill 发送信号 sig 给进程组 `|pid|`（pid 的绝对值）中的每个进程。
 
 图 8-29 展示了一个示例，父进程用 kill 函数发送 SIGKILL 信号给它的子进程。

~~~c
// kill.c
#include "csapp.h"

int main()
{
    pid_t pid;

    /* Child sleeps until SIGKILL signal received, then dies */
    if ((pid = Fork()) == 0) {
        Pause(); /* Wait for a signal to arrive */
        printf("control should never reach here!\n");
        exit(0);
    }

    /* Parent sends a SIGKILL signal to a child */
    Kill(pid, SIGKILL);
    exit(0);
}
~~~

您提供的代码是一个简单的 C 程序示例，展示了父进程如何创建一个子进程，并向该子进程发送 `SIGKILL` 信号以终止它。
在这个示例中，使用了 `Fork`、`Pause` 和 `Kill` 这几个函数。这里是代码的详细解释：

### 代码解释

1. **创建子进程**:
   - 使用 `Fork()` 创建一个新的子进程。这里假设 `Fork()` 是对标准 `fork()` 函数的封装，它在出错时自行处理错误（比如打印错误信息并退出）。
   - `fork()` 函数会返回两次：在父进程中返回子进程的 PID，在子进程中返回 0。

2. **子进程行为**:
   - 在子进程中（`Fork()` 返回 0），调用 `Pause()` 函数。`Pause()` 是一个阻塞函数，它使得进程休眠直到接收到一个信号。对于 `SIGKILL` 信号，它将终止进程，因此后面的 `printf` 语句永远不会执行。

3. **父进程行为**:
   - 在父进程中，`Fork()` 返回子进程的 PID。父进程使用 `Kill(pid, SIGKILL)` 向子进程发送 `SIGKILL` 信号。这会立即终止子进程。
   - 这里假设 `Kill` 是对标准 `kill()` 函数的封装，可能同样在出错时进行错误处理。

4. **程序结束**:
   - 子进程接收到 `SIGKILL` 信号后被终止，不会执行任何清理操作或执行后续代码。
   - 父进程在发送 `SIGKILL` 信号后调用 `exit(0)` 结束。

### 代码示例的目的

此代码示例演示了如何在父进程中创建一个子进程，然后使用信号来控制子进程。
`SIGKILL` 是一个强制终止信号，不能被捕获、阻塞或忽略。这个示例通常用于展示信号和进程控制的基本概念。


### 5. 用 `alarm` 函数发送信号

进程可以通过调用 alarm 函数向它自己发送 SIGALRM 信号。

~~~c
#include <unistd.h>
unsigned int alarm(unsigned int secs);

// 返回：前一次闹钟剩余的秒数，若以前没有设定闹钟，则为0。
~~~

`alarm` 函数是 Unix 和类 Unix 系统（如 Linux）中的一个系统调用，它用于设置一个计时器（闹钟）。
当指定的时间（以秒为单位）流逝后，系统会给调用 `alarm` 的进程发送 `SIGALRM` 信号。
这个函数通常用于实现超时检测或者在特定时间后执行某个操作。以下是 `alarm` 函数的基本信息：

### 函数原型
```c
unsigned int alarm(unsigned int secs);
```

### 参数
- **secs**：要设置的计时器时间，单位是秒。当 `secs` 为零时，任何先前设置的闹钟会被取消。

### 返回值
- `alarm` 函数返回先前闹钟的剩余时间（秒），如果之前没有设置闹钟，则返回 0。
- 如果调用 `alarm` 时，之前的闹钟还没响，它会返回之前闹钟剩余的时间，并用新的时间替换它。

### 行为
- 在 `secs` 秒后，如果进程仍然存在，它将接收到 `SIGALRM` 信号。
- 如果进程没有处理 `SIGALRM` 信号（即没有使用 `signal` 或 `sigaction` 等函数设置信号处理函数），则信号的默认行为（终止进程）将发生。
- 可以在信号处理函数中编写特定的代码来处理 `SIGALRM` 信号，如执行某些清理操作或设置一个标志。

### 示例用法

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void alarm_handler(int sig) {
    printf("Alarm signal received\n");
    // 执行一些操作，比如超时处理
}

int main() {
    signal(SIGALRM, alarm_handler);
    alarm(5);  // 设置 5 秒闹钟

    // 执行一些操作
    pause();  // 等待信号到达

    return 0;
}
```

在这个示例中，程序设置了一个 5 秒的计时器。当计时器到达 5 秒时，`alarm_handler` 函数将被调用。

### 注意事项

- `alarm` 函数只能为每个进程设置一个闹钟计时器。新的 `alarm` 调用会覆盖先前的设置。
- 在多线程环境下使用 `alarm` 需要小心，因为 `SIGALRM` 信号可能被发送到同一进程的任何线程。


## 接收信号

当内核把进程 `p` 从内核模式切换到用户模式时（例如，从系统调用返回或是完成了一次上下文切换），它会检查进程 `p` 的未被阻塞的待处理信号的集合（`pending &~blocked`）。如果这个集合为空（通常情况下），那么内核将控制传递到 `p` 的逻辑控制流中的下一条指令（`I_next`）。

然而，如果集合是非空的，那么内核选择集合中的某个信号 `k` （通常是最小的 k），并且强制 `p` 接收信号 k。
收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回 `p` 的逻辑控制流中的下一条指令（`I_next`）。
每个信号类型都有一个预定义的默认行为，是下面中的一种：
 - 进程终止。
 - 进程终止并转储内存。
 - 进程停止（挂起）直到被 SIGCONT 信号重启。
 - 进程忽略该信号。

当内核检测到一个进程 `p` 有未被阻塞的待处理信号时，它将强制进程 `p` 处理这个信号。
这是操作系统信号处理机制的关键部分，确保进程能够响应各种重要的事件和异常情况。
以下是对这个过程的进一步阐释，以及每种信号类型可能的预定义默认行为：

### 信号处理过程

1. **信号检查**：当进程从内核模式切换到用户模式时，内核会检查进程的待处理信号集合。这个检查考虑了进程当前阻塞的信号（即不应处理的信号）。
2. **选择信号处理**：如果存在未被阻塞的待处理信号，内核会选择一个信号（通常是编号最小的）进行处理。
3. **触发行为**：根据被选中的信号 `k`，进程会执行与该信号关联的特定行为。这可能涉及执行一个信号处理函数（如果进程为该信号设置了处理函数），或执行信号的默认行为。
4. **控制流回传**：一旦信号处理完成，进程继续其正常的逻辑控制流，执行下一条指令。

### 信号的默认行为

每个信号类型都有一个预定义的默认行为，这些行为通常是以下几种之一：
- **终止（Terminate）**：默认情况下，大多数信号会导致进程终止。例如，`SIGTERM` 和 `SIGKILL` 都是导致进程终止的信号。
- **忽略（Ignore）**：某些信号可以被默认忽略。例如，`SIGCHLD` 通常默认被忽略，这个信号在子进程结束时发送给父进程。
- **停止（Stop）**：一些信号导致进程停止执行，直到进程收到继续执行的信号。例如，`SIGSTOP` 导致进程停止，而 `SIGCONT` 用于恢复进程的执行。
- **产生核心转储文件（Core Dump）**：对于严重错误，如非法操作或段错误（例如，`SIGSEGV` 和 `SIGABRT`），默认行为可能包括终止进程并产生一个核心转储文件，以便进行进一步的调试。

### 修改接受到信号的默认行为
图 8-26 展示了与每个信号类型相关联的默认行为。比如，收到 `SIGKILL` 的默认行为就是终止接收进程。另外，接收到 `SIGCHLD` 的默认行为就是忽略这个信号。进程可以通过使用 `signal` 函数修改和信号相关联的默认行为。唯一的例外是 `SIGSTOP` 和 `SIGKILL`，它们的默认行为是不能修改的。

~~~c
#include <signal.h>
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);

// 返回：若成功则为指向前次处理程序的指针，若出错则为 SIG_ERR（不设置 errno）。
~~~

`signal` 函数可以通过下列三种方法之一来改变和信号 signum 相关联的行为：
 - 如果 handler 是 `SIG_IGN`，那么忽略类型为 signum 的信号。
 - 如果 handler 是 `SIG_DFL`，那么类型为 signum 的信号行为恢复为默认行为。
 - 否则，handler 就是用户定义的函数的地址，这个函数被称为**信号处理程序**
 只要进程接收到一个类型为 signum 的信号，就会调用这个程序。
 通过把处理程序的地址传递到 signal 函数从而改变默认行为，这叫做设置信号处理程序（*installing the handler*）。
 调用信号处理程序被称为捕获信号。
 执行信号处理程序被称为处理信号。

当一个进程捕获了一个类型为 `k` 的信号时，会调用为信号 `k` 设置的处理程序，一个整数参数被设置为 `k`。
这个参数允许同一个处理函数捕获不同类型的信号。

当处理程序执行它的 return 语句时，控制（通常）传递回控制流中进程被信号接收中断位置处的指令。
我们说“通常”是因为在某些系统中，被中断的系统调用会立即返回一个错误。

图 8-30 展示了一个程序，它捕获用户在键盘上输入 `Ctrl+C` 时发送的 `SIGINT` 信号。`SIGINT` 的默认行为是立即终止该进程。
在这个示例中，我们将默认行为修改为捕获信号，输出一条消息，然后终止该进程。

~~~c
#include "csapp.h"

void sigint_handler(int sig) /* SIGINT handler */
{
    printf("Caught SIGINT!\n");
    exit(0);
}

int main()
{
    /* Install the SIGINT handler */
    if (signal(SIGINT, sigint_handler) == SIG_ERR)
    unix_error("signal error");

    pause(); /* Wait for the receipt of a signal */

    return 0;
}
~~~

在 Unix 和类 Unix 系统中，进程可以为不同的信号设置特定的处理函数。
当一个信号被捕获时，相应的处理函数会被调用，并接收一个整数参数，该参数表示被捕获的信号的类型。
这种机制允许单个处理函数根据传入的信号类型来执行不同的操作，从而提高代码的复用性和程序的灵活性。

### 信号处理函数的基本原型

信号处理函数通常具有以下基本原型：

```c
void signal_handler(int signum) {
    // 信号处理代码
}
```

其中，`signum` 参数是一个整数，表示被捕获的信号的类型。
例如，如果处理函数是为 `SIGINT` 信号设置的，当 `SIGINT` 被捕获时，`signum` 的值将为 `SIGINT` 所对应的整数值。

### 设置信号处理函数

您可以使用 `signal` 或 `sigaction` 函数来为特定的信号设置处理函数。例如，使用 `signal` 函数：

```c
#include <signal.h>

void signal_handler(int signum) {
    if (signum == SIGINT) {
        // 处理 SIGINT 信号
    } else if (signum == SIGTERM) {
        // 处理 SIGTERM 信号
    }
    // 其他信号处理
}

int main() {
    // 为 SIGINT 和 SIGTERM 设置相同的处理函数
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    // 其他代码
}
```

在这个示例中，`signal_handler` 函数可以处理 `SIGINT` 和 `SIGTERM` 两种信号。
当其中一个信号被捕获时，处理函数将根据 `signum` 参数的值来确定是哪种信号被捕获，并执行相应的操作。

### 优点

- **灵活性**：这种机制允许相同的处理函数响应多种信号，使得程序设计更加灵活。
- **简化代码**：能够减少重复的代码，特别是当多个信号需要执行类似的处理逻辑时。

### 注意事项

- 信号处理函数应该尽可能简单，避免执行复杂的操作，特别是那些可能会导致阻塞的操作。
- 在信号处理函数中修改全局状态时，应当注意同步和原子性的问题，避免潜在的竞态条件。

信号处理程序可以被其他信号处理程序中断，如图 8-31 所示。
在这个例子中，主程序捕获到信号 s，该信号会中断主程序，将控制转移到处理程序 S。
S 在运行时，程序捕获信号 `t≠s`，该信号会中断 `S`，控制转移到处理程序 `T`。
当 `T` 返回时，`S` 从它被中断的地方继续执行。最后，`S` 返回，控制传送回主程序，主程序从它被中断的地方继续执行。

====================================================================================================
编写一个叫做 snooze 的程序，它有一个命令行参数，用这个参数调用练习题 8.5 中的 `snooze` 函数，然后终止。
编写程序，使得用户可以通过在键盘上输入 Ctrl+C 中断 `snooze` 函数。比如：

只要休眠进程收到一个未被忽略的信号，sleep 函数就会提前返回。
但是，因为收到一个 `SIGINT` 信号的默认行为就是终止进程（图 8-26），我们必须设置一个 SIGINT 处理程序来允许 sleep 函数返回。
处理程序简单地捕获 SIGNAL，并将控制返回给 sleep 函数，该函数会立即返回。
~~~c
#include "csapp.h"

/* SIGINT handler */
void handler(int sig)
{
    return; /* Catch the signal and return */
}

unsigned int snooze(unsigned int secs) {
    unsigned int rc = sleep(secs);

    printf("Slept for %d of %d secs.\n", secs - rc, secs);

    return rc;
}

int main(int argc, char **argv) {
    
    if (argc != 2) {
        fprintf(stderr, "usage: %s <secs>\n", argv[0]);
        exit(0);
    }

    if (signal(SIGINT, handler) == SIG_ERR) /* Install SIGINT */
        unix_error("signal error\n"); /* handler */

    (void)snooze(atoi(argv[1])); exit(0);
}
~~~

您提供的代码是一个 C 程序，它展示了如何使用 `signal` 函数来安装一个信号处理器，并使用 `sleep` 函数在接收到 `SIGINT` 信号（通常由 `Ctrl+C` 产生）时进行中断处理。
这个程序还包含了一个 `snooze` 函数，用于演示 `sleep` 被信号中断后的行为。以下是对这段代码的分析和说明：

### 代码解析

1. **信号处理器（handler）**:
   - `handler` 是一个信号处理函数，它被设计为接收一个信号（在这个例子中是 `SIGINT`），并且仅仅返回而不执行任何操作。
   这意味着当接收到 `SIGINT` 信号时，程序将捕获并忽略它。

2. **`snooze` 函数**:
   - `snooze` 函数调用 `sleep`，使程序暂停执行指定的秒数。如果 `sleep` 被信号中断，它会提前返回，并且返回值是剩余未睡眠的时间。
   - 然后，`snooze` 函数打印实际睡眠的时间。

3. **主函数（main）**:
   - 程序首先检查命令行参数的数量，确保提供了一个参数（睡眠的秒数）。
   - 接着，程序使用 `signal` 函数将 `SIGINT` 信号的处理器设置为 `handler` 函数。
   - 最后，调用 `snooze` 函数，并传入用户指定的睡眠时间。

### 运行流程

- 当程序运行时，它会根据命令行参数进入睡眠状态。
- 如果在睡眠期间用户按下 `Ctrl+C`，则 `SIGINT` 信号被生成并发送到程序。
- 由于程序为 `SIGINT` 安装了 `handler` 处理器，信号被捕获并处理，但 `handler` 函数本身不执行任何操作。
- 此时 `sleep` 函数被中断，提前返回，并且 `snooze` 函数打印实际睡眠的时间。

这个程序是一个很好的示例，用于演示如何在 C 程序中处理信号，特别是如何处理 `sleep` 函数的中断和信号处理函数的基本使用。
====================================================================================================


## 阻塞和解除阻塞信号

Linux 提供阻塞信号的隐式和显式的机制：
**隐式阻塞机制** 内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。例如，图 8-31 中，假设程序捕获了信号 `s`，当前正在运行处理程序 `S`。如果发送给该进程另一个信号 `s`，那么直到处理程序 `S` 返回，`s` 会变成待处理而没有被接收。
**显式阻塞机制** 应用程序可以使用 `sigprocmask` 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

~~~c
#include <signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
//返回；如果成功则为 0，若出错则为 -1。

int sigismember(const sigset_t *set, int signum);
// 返回：若 signum 是 set 的成员则为 1，如果不是则为 0，若出错则为 -1。
~~~

隐式阻塞和显式阻塞。这两种机制在信号处理中扮演着重要的角色，使得进程可以更精确地控制对信号的响应。
以下是对这两种机制的详细解释：

### 隐式阻塞机制

- **工作原理**：当一个信号的处理程序（handler）正在执行时，相同类型的信号会被自动阻塞。
这意味着如果处理程序正在处理一个特定类型的信号（比如 `SIGINT`），在这段时间内发送到进程的同类型信号（`SIGINT`）不会被递送，直到当前的处理程序返回。

- **目的**：这种机制的主要目的是防止递归信号处理，即避免在处理一个特定信号的过程中再次进入该信号的处理程序。
这有助于简化信号处理程序的设计，使其更安全、更可预测。

### 显式阻塞机制

- **工作原理**：进程可以使用 `sigprocmask` 函数以及相关的辅助函数来显式地阻塞或解除阻塞特定的信号。
通过修改信号掩码（signal mask），进程可以指定在特定代码段执行期间不希望接收的信号。

- **函数用法**：
  - `sigprocmask(SIG_BLOCK, &set, &oldset)`：阻塞 `set` 中指定的信号。
  - `sigprocmask(SIG_UNBLOCK, &set, &oldset)`：解除阻塞 `set` 中指定的信号。
  - `sigprocmask(SIG_SETMASK, &set, &oldset)`：将当前信号掩码设置为 `set`。

- **目的**：显式阻塞机制允许进程在执行关键代码段时防止特定信号的干扰，提高代码的原子性和稳定性。
例如，在更新全局数据结构或执行事务性操作时，进程可能希望暂时阻塞某些信号。

### 总结

这两种阻塞机制提供了灵活的方式来处理信号，确保了程序的健壮性和稳定性。隐式阻塞避免了信号处理程序的递归调用，而显式阻塞允许程序开发者在执行关键任务时控制信号的递送。正确地使用这些机制对于编写可靠的并发程序和信号敏感的应用程序至关重要。

`sigprocmask` 函数改变当前阻塞的信号集合（8.5.1 节中描述的 blocked 位向量）。具体的行为依赖于 how 的值：
`SIG_BLOCK`：把 set 中的信号添加到 blocked 中（`blocked=blocked | set`）。
`SIG_UNBLOCK`：从 blocked 中删除 set 中的信号（`blocked=blocked &~set`）。
`SIG_SETMASK`：`block=set`。

如果 `oldset` 非空，那么 blocked 位向量之前的值保存在 `oldset` 中。

### Some API
使用下述函数对 set 信号集合进行操作：`sigemptyset` 初始化 set 为空集合。
`sigfillset` 函数把每个信号都添加到 set 中。
`sigaddset` 函数把 signum 添加到 set，
`sigdelset` 从 set 中删除 signum，
如果 signum 是 set 的成员，那么 `sigismember` 返回 1，否则返回 0。

例如，图 8-32 展示了如何用 sigprocmask 来临时阻塞接收 SIGINT 信号。
~~~c
sigset_t mask, prev_mask;

Sigemptyset(&mask);
Sigaddset(&mask, SIGINT);

/* Block SIGINT and save previous blocked set */
Sigprocmask(SIG_BLOCK, &mask, &prev_mask);
.
.  // Code region that will not be interrupted by SIGINT
.
/* Restore previous blocked set, unblocking SIGINT */
Sigprocmask(SIG_SETMASK, &prev_mask, NULL);

// 临时阻塞接收一个信号
~~~


当然，让我给您一个示例，说明如何在 C 语言中使用 `sigprocmask` 来显式阻塞和解除阻塞信号。
这个示例将展示如何在关键代码段执行期间阻塞 `SIGINT` 信号（通常由 `Ctrl+C` 触发），然后在关键代码执行完毕后解除阻塞。

### 示例代码

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void sigint_handler(int sig) {
    printf("Caught SIGINT\n");
}

int main() {
    sigset_t newset, oldset;

    // 设置 SIGINT 的处理函数
    signal(SIGINT, sigint_handler);

    // 初始化信号集 newset，并添加 SIGINT 信号
    sigemptyset(&newset);
    sigaddset(&newset, SIGINT);

    // 阻塞 SIGINT 信号，并保存当前信号掩码
    sigprocmask(SIG_BLOCK, &newset, &oldset);

    // 执行关键代码段
    printf("Critical section start\n");
    sleep(5); // 模拟长时间执行
    printf("Critical section end\n");

    // 解除阻塞 SIGINT 信号
    sigprocmask(SIG_SETMASK, &oldset, NULL);

    // 程序继续执行，可以响应 SIGINT 信号
    printf("SIGINT is now unblocked\n");
    sleep(5);

    return 0;
}
```

### 代码解释

1. **设置信号处理函数**：首先，为 `SIGINT` 信号设置了一个简单的处理函数 `sigint_handler`。

2. **阻塞 `SIGINT` 信号**：
   - 使用 `sigemptyset` 和 `sigaddset` 初始化一个新的信号集 `newset`，并将 `SIGINT` 信号加入到这个集合中。
   - 使用 `sigprocmask` 将 `SIGINT` 信号添加到当前进程的信号掩码中，从而阻塞该信号。同时，将当前的信号掩码保存在 `oldset` 中。

3. **执行关键代码段**：在 `sleep(5)` 期间模拟一个关键代码段的执行。在这段时间内，即使用户发送 `SIGINT` 信号，由于该信号被阻塞，程序不会响应。

4. **解除阻塞 `SIGINT` 信号**：
   - 关键代码段执行完毕后，使用 `sigprocmask` 和之前保存的 `oldset` 恢复原来的信号掩码，从而解除对 `SIGINT` 信号的阻塞。

5. **程序继续执行**：解除阻塞后，程序可以正常响应 `SIGINT` 信号。

### 运行和测试

运行这个程序，并在执行期间尝试按下 `Ctrl+C`。您会发现，在关键代码段执行期间，程序不会响应 `Ctrl+C`。一旦退出关键代码段，`Ctrl+C` 将会被正常捕获并调用信号处理函数。



# ⭐⭐⭐ 编写信号处理程序
信号处理是 Linux 系统编程最棘手的一个问题。
处理程序有几个属性使得它们很难推理分析：
 - 处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰；
 - 如何以及何时接收信号的规则常常有违人的直觉；
 - 不同的系统有不同的信号处理语义。
在本节中，我们将讲述这些问题，介绍编写安全、正确和可移植的信号处理程序的一些基本规则。

====================================================================================================
由于信号处理程序（signal handlers）的特殊性质，确实存在一些与常规函数不同的注意事项。
以下是编写安全、正确和可移植的信号处理程序时需要遵循的一些基本规则和最佳实践：

### 1. 避免共享变量的使用
- 由于信号处理程序和主程序可以并发运行，它们可能会同时访问和修改相同的全局变量，导致竞态条件和不可预测的行为。
因此，应尽量避免在信号处理程序中访问和修改全局变量。
- 如果必须使用全局变量，应确保访问它们的操作是原子的，或者使用适当的同步机制（如互斥锁）来防止竞态条件，但注意信号处理程序中不能使用可能导致阻塞的同步原语。

### 2. 使用 `sig_atomic_t` 类型的变量
- 当需要在信号处理程序和主程序之间共享数据时，可以使用 `volatile sig_atomic_t` 类型的变量。
这种类型的访问被保证是原子的，即在单个机器指令中完成，不会被中断。

### 3. 限制信号处理程序中的操作
- 信号处理程序应该尽可能简单，避免执行复杂的逻辑或调用可能阻塞的系统调用（如 I/O 操作、`malloc`、`free` 等）。
- 最佳做法是仅在信号处理程序中设置一个标志变量，由主程序轮询这个变量并执行实际的处理逻辑。

### 4. 了解信号的递送和处理规则
- 不同的信号具有不同的默认行为（如终止进程、忽略等）。了解这些行为对于正确处理信号至关重要。
- 了解信号的阻塞和掩码机制，可以有选择性地阻塞或允许特定信号。

### 5. 考虑不同系统间的差异
- 不同的 Unix-like 系统在信号处理的实现细节上可能有所不同。编写可移植的信号处理代码时，需要考虑这些差异。
- 尽量使用标准的 POSIX 接口和语义，这些通常在不同的系统间具有一致性。

### 6. 使用 `sigaction` 而非 `signal`

- 建议使用 `sigaction` 函数而不是 `signal` 函数来设置信号处理程序。`sigaction` 提供了更多控制选项，行为也更加一致可预测。

### 总结

信号处理的确是系统编程中的一个复杂领域。正确地处理信号需要对操作系统的信号机制有深入的理解，以及对并发编程中的挑战和陷阱有清晰的认识。遵循上述规则和最佳实践可以帮助开发者编写出更安全、更可靠、更可移植的信号处理代码。
====================================================================================================

## 1. 安全的信号处理

我们会在第 12 章详细讲述并发编程。
这里我们的目标是给你一些保守的编写处理程序的原则，使得这些处理程序能安全地并发运行。
如果你忽视这些原则，就可能有引入细微的并发错误的风险。如果有这些错误，程序可能在绝大部分时候都能正确工作。
然而当它出错的时候，就会错得不可预测和不可重复，这样是很难调试的。一定要防患于未然！

- **G0. 处理程序要尽可能简单** 避免麻烦的最好方法是保持处理程序尽可能小和简单。
例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查（并重置）这个标志。

- **G1. 在处理程序中只调用异步信号安全的函数** 所谓异步信号安全的函数（或简称安全的函数）能够被信号处理程序安全地调用，原因有二：要么它是可重入的（例如只访问局部变量，见 12.7.2 节），要么它不能被信号处理程序中断。
图 8-33 列出了 Linux 保证安全的系统级函数。注意，许多常见的函数（例如 printf、sprintf、malloc 和 exit）都不在此列。

信号处理程序中产生输出唯一安全的方法是使用 `write` 函数（见 10.1 节）。特别地，调用 printf 或 sprintf 是不安全的。为了绕开这个不幸的限制，我们开发一些安全的函数，称为 `SIO`（安全的 I/O）包，可以用来在信号处理程序中打印简单的消息。

~~~c
#include "csapp.h"

ssize_t sio_putl(long v);
ssize_t sio_puts(char s[]);
// 返回：如果成功则为传送的字节数，如果出错，则为 -1。

void sio_error(char s[]);
// 返回：空。
~~~

`sio_putl` 和 `sio_puts` 函数分别向标准输出传送一个 long 类型数和一个字符串。`sio_error` 函数打印一条错误消息并终止。

图 8-34 给出的是 SIO 包的实现，它使用了 csapp.c 中两个私有的可重入函数。
第 3 行的 sio_strlen 函数返回字符串 s 的长度。
第 10 行的 sio_ltoa 函数基于来自【61】的 itoa 函数，把 v 转换成它的基 b 字符串表示，保存在 s 中。
第 17 行的 _exit 函数是 exit 的一个异步信号安全的变种。

~~~c
ssize_t sio_puts(char s[]) /* Put string */
{
    return write(STDOUT_FILENO, s, sio_strlen(s));
}

ssize_t sio_putl(long v) /* Put long */
{
    char s[128];

    sio_ltoa(v, s, 10); /* Based on K&R itoa() */
    return sio_puts(s);
}

void sio_error(char s[]) /* Put error message and exit */
{
    sio_puts(s);
    _exit(1);
}
~~~

当然，我可以用更通俗的方式解释这些信号处理的原则，并结合一些简单的例子来说明。

### 1. 避免共享变量的使用

**通俗解释**：
就像两个人同时编辑同一份文档一样，如果不小心，他们可能互相覆盖对方的更改。在信号处理程序中，你应该避免更改主程序中也在使用的变量，因为这可能导致数据混乱。

**例子**：
假设你有一个全局计数器，既在主程序中增加，也在信号处理函数中增加。如果信号在主程序增加计数器的同时到达，计数器的最终值可能不正确。

### 2. 使用 `sig_atomic_t` 类型的变量

**通俗解释**：
想象一下，你在写一张纸条，但希望避免别人在你还没写完时就读它。使用 `sig_atomic_t` 类型的变量就像是确保你能一笔写完纸条，并且只有完全写完后别人才能读它。

**例子**：
你可以用 `sig_atomic_t` 类型的变量来记录信号是否到达，因为这种类型的变量读写操作是安全的，不会被打断。

### 3. 限制信号处理程序中的操作

**通俗解释**：
信号处理就像是紧急情况下的疏散演习。你应该尽快完成，不要做任何复杂的事情。最好只是打个标记（比如打开一个紧急出口标志），然后在安全的时候处理更复杂的任务。

**例子**：
如果你收到一个退出信号，你的信号处理函数应该只是设置一个退出标志。主程序定期检查这个标志，并在适当的时候安全地退出。

### 4. 了解信号的递送和处理规则

**通俗解释**：
这就像了解不同国家的交通规则一样。即使基本原则相同（比如红灯停，绿灯行），但每个地方可能都有一些特殊规定。

**例子**：
`SIGKILL` 信号总是会终止一个程序，不能被阻塞或捕获。了解这一点可以帮助你理解为什么有时你的程序无法处理某些特定的信号。

### 5. 考虑不同系统间的差异

**通俗解释**：
就像不同的电子设备可能需要不同的电压一样，不同的操作系统可能对信号有不同的处理方式。编写可移植的代码意味着你的程序能够适应这些差异。

**例子**：
在某些系统上，`signal()` 函数可能在信号处理后重置为默认行为，而在其他系统上则不会。使用 `sigaction()` 可以在更多系统上提供一致的行为。

### 6. 使用 `sigaction` 而非 `signal`

**通俗解释**：
使用 `sigaction` 就像是拥有一个多功能的遥控器，而 `signal` 更像是一个只有开关按钮的简单遥控器。`sigaction` 提供更多控制选项和灵活性。

**例子**：
使用 `sigaction`，你可以更精确地定义信号处理函数的行为，比如指定在执行处理函数时哪些信号应该被阻塞。

### 总结
信号处理就像是处理紧急情况的一套规则和工具。理解和遵守这些规则可以帮助你安全、有效地管理这些紧急情况，避免意外或错误。


